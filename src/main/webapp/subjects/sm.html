<!DOCTYPE html>
<html>
<head>
	
</head>
<body>

	<h1><span class="color_h1" style="color: darkviolet;">SOFTWARE MAINTENANCE</span></h1><hr>
    <div>
        <p>Software maintenance is widely accepted part of SDLC now a days.  It stands for all the modifications and updations done after the delivery of software product.  There are number of reasons, why modifications are required, some of them are briefly mentioned below:</p>
    <ul class="list">
    <li><p><b>Market Conditions </b> - Policies, which changes over the time, such as taxation and newly introduced constraints like, how to maintain bookkeeping, may trigger need for modification.</p></li>
    <li><p><b>Client Requirements</b> - Over the time, customer may ask for new features or functions in the software.</p></li>
    <li><p><b>Host Modifications </b> - If any of the hardware and/or platform (such as operating system) of the target host changes, software changes are needed to keep adaptability.</p></li>
    <li><p><b>Organization Changes</b> - If there is any business level change at client end, such as reduction of organization strength, acquiring another company, organization venturing into new business, need to modify in the original software may arise.</p></li>
    </ul>
    <h2>Types of maintenance </h2>
    <p>In a software lifetime, type of maintenance may vary based on its nature.  It may be just a routine maintenance tasks as some bug discovered by some user or it may be a large event in itself based on maintenance size or nature.  Following are some types of maintenance based on their characteristics:</p>
    <ul class="list">
    <li><p><b>Corrective Maintenance</b> - This includes modifications and updations done in order to correct or fix problems, which are either discovered by user or concluded by user error reports.</p></li>
    <li><p><b>Adaptive Maintenance</b> - This includes modifications and updations applied to keep the software product up-to date and tuned to the ever changing world of technology and business environment.</p></li>
    <li><p><b>Perfective Maintenance</b> - This  includes modifications and updates done in order to keep the software usable over long period of time. It includes new features, new user requirements for refining the software and improve  its reliability and performance.</p></li>
    <li><p><b>Preventive Maintenance</b> - This includes modifications and updations to prevent future problems of the software. It aims to attend problems, which are not significant at this moment but may cause serious issues in future.</p></li>
    </ul>
    <h2>Cost of Maintenance</h2>
    <p>Reports suggest that the cost of maintenance is high. A study on estimating software maintenance found that the cost of maintenance is as high as 67% of the cost of entire software process cycle.</p>
    <img src="/software_engineering/images/maintenance_cost_chart.png" alt="Maintenance Cost Chart">
    <p>On an average, the cost of software maintenance is more than 50% of all SDLC phases. There are various factors, which trigger maintenance cost go high, such as: </p>
    <h3>Real-world factors affecting Maintenance Cost</h3>
    <ul class="list">
    <li>The standard age of any software is considered up to 10 to 15 years.</li>
    <li>Older softwares, which were meant to work on slow machines with less memory and storage capacity cannot keep themselves challenging against newly coming enhanced softwares on modern hardware.</li>
    <li>As technology advances, it becomes costly to maintain old software.</li>
    <li>Most maintenance engineers are newbie and use trial and error method to rectify problem.</li>
    <li>Often, changes made can easily hurt the original structure of the software, making it hard for any subsequent changes.</li>
    <li>Changes are often left undocumented which may cause more conflicts in future.</li>
    </ul>
    <h3>Software-end factors  affecting Maintenance Cost</h3>
    <ul class="list">
    <li>Structure of Software Program</li>
    <li>Programming Language </li>
    <li>Dependence on external environment</li>
    <li>Staff reliability and availability</li>
    </ul>
    <h2>Maintenance Activities</h2>
    <p>IEEE provides a framework for sequential maintenance process activities.  It can be used in iterative manner and can be extended so that customized items and processes can be included. </p>
    <img src="/software_engineering/images/maintenance_activities.png" alt="Maintenance Activities">
    <p>These activities go hand-in-hand with each of the following phase:</p>
    <ul class="list">
    <li><p><b>Identification &amp; Tracing</b> - It involves activities pertaining to identification of requirement of  modification or maintenance.  It is generated by user or system may itself report via logs or error messages.Here, the maintenance type is classified also.</p></li>
    <li><p><b>Analysis</b> - The modification is analyzed for its impact on the system including safety and security implications. If probable impact is severe, alternative solution is looked for. A set of required modifications is then materialized into requirement specifications. The cost of modification/maintenance is analyzed and estimation is concluded.</p></li>
    <li><p><b>Design</b> - New modules, which need to be replaced or modified, are designed against requirement specifications set in the previous stage. Test cases are created for validation and verification.</p></li>
    <li><p><b>Implementation</b> - The new modules are coded with the help of structured design created in the design step.Every programmer is expected to do unit testing in parallel.</p></li>
    <li><p><b>System Testing</b> - Integration testing is done among newly created modules. Integration testing is also carried out between  new modules and the system. Finally the system is tested as a whole, following regressive testing procedures.</p></li>
    <li><p><b>Acceptance Testing</b> - After testing the system internally, it is tested for acceptance with the help of users. If at this state, user complaints some issues they are addressed or noted to address in next iteration.</p></li>
    <li><p><b>Delivery</b> - After acceptance test, the system is deployed all over the organization either by small update package or fresh installation of the system. The final testing takes place at client end after the software is delivered. </p>
    <p>Training facility is provided if required, in addition to the hard copy of user manual.</p></li>
    <li><p><b>Maintenance management</b> - Configuration management is an essential part of system maintenance. It is aided with version control tools to control versions, semi-version or patch management.</p></li>
    </ul>
    <h2>Software Re-engineering</h2>
    <p>When we need to update the software to keep it to the current market, without impacting its functionality, it is called software re-engineering. It is a thorough process  where the design of software is changed and programs are re-written.</p>
    <p>Legacy software cannot keep tuning with the latest technology available in the market. As the hardware become obsolete, updating of software becomes a headache. Even if software  grows old with time, its functionality does not.  </p>
    <p>For example, initially Unix was developed in assembly language. When language C came into existence, Unix was re-engineered in C, because working in assembly language was difficult.</p>
    <p>Other than  this, sometimes programmers notice that few parts of software need more maintenance than others and they  also need re-engineering.</p>
    <img src="/software_engineering/images/reengineering_process.png" alt="Process of Re-Engineering">
    <h3>Re-Engineering Process</h3>
    <ul class="list">
    <li><b>Decide</b> what to re-engineer.  Is it whole software or a part of it?</li>
    <li><b>Perform</b> Reverse Engineering, in order to obtain specifications of existing software.</li>
    <li><b>Restructure Program</b> if required. For example, changing function-oriented programs into object-oriented programs.</li>
    <li><b>Re-structure data</b> as required.</li>
    <li><b>Apply Forward engineering</b> concepts in order to get re-engineered software.</li>
    </ul>
    <p>There are few important terms used in Software re-engineering</p>
    <h3>Reverse Engineering</h3>
    <p>It is a process to achieve system specification by thoroughly analyzing, understanding the existing system.  This process can be seen as reverse SDLC model, i.e. we try to get higher abstraction level by analyzing lower abstraction levels.</p>
    <p>An existing system is previously implemented design, about which we know nothing.  Designers then do reverse engineering by looking at the code and try to get the design.  With design in hand, they try to conclude the specifications.  Thus, going in reverse from code to system specification.</p>
    <img src="/software_engineering/images/reverse_engineering.png" alt="Reverse Engineering">
    <h3>Program Restructuring</h3>
    <p>It is a process to re-structure and re-construct the existing software.  It is all about re-arranging the source code, either in same programming language or from one programming language to a different one.  Restructuring can have either source code-restructuring and data-restructuring or both.</p>
    <p>Re-structuring does not impact the functionality of the software but enhance reliability and maintainability.  Program  components, which cause errors very frequently can be changed, or updated with re-structuring.</p>
    <p>The dependability of software on obsolete hardware platform can be removed via re-structuring.</p>
    <h3>Forward Engineering</h3>
    <p>Forward engineering is a process of obtaining desired software from the specifications in hand which were brought down by means of reverse engineering. It assumes that there was some software engineering already done in the past.</p>
    <p> Forward engineering is same as software engineering process with only one difference – it is carried out always after reverse engineering.</p>
    <img src="/software_engineering/images/forward_engineering.png" alt="Forward Engineering">
    <h2>Component reusability</h2>
    <p>A component is a part of software program code, which executes an independent task in the system.  It can be a small module or sub-system itself.</p>
    <h3>Example</h3>
    <p>The login procedures used on the web can be considered as components, printing system in software can be seen as a component of the software.</p>
    <p>Components have high  cohesion of functionality and lower rate of coupling, i.e. they work independently and can perform tasks without depending on other modules.</p>
    <p>In OOP, the objects are designed are very specific to their concern and have fewer chances to be used in some other software. </p>
    <p>In modular programming, the modules are coded to perform specific tasks which can be used across number of other software programs.</p>
    <p>There is a whole new vertical, which is based on re-use of software component, and is known as Component Based Software Engineering (CBSE).</p>
    <img src="/software_engineering/images/components.png" alt="Components">
    <p>Re-use can be done at various levels</p>
    <ul class="list">
    <li><p><b>Application level </b> - Where an entire application is used as sub-system of new software.</p></li>
    <li><p><b>Component level </b> -  Where sub-system of an application is used.</p></li>
    <li><p><b>Modules level </b> - Where functional modules are re-used.</p>
    <p>Software components provide interfaces, which can be used to establish communication among different components.</p></li>
    </ul>
    <h3>Reuse Process</h3>
    <p>Two kinds of method can be adopted: either by keeping requirements same and adjusting components or by keeping components same and modifying requirements.</p>
    <img src="/software_engineering/images/reuse_process.png" alt="Reuse Process">
    <ul class="list">
    <li><p><b>Requirement Specification</b> - The functional and non-functional requirements are specified, which a software product must comply to, with the help of existing system, user input or both. </p></li>
    <li><p><b>Design</b> - This is also a standard SDLC process step, where requirements are defined in terms of software parlance.  Basic architecture of system as a whole and its sub-systems are created.</p></li>
    <li><p><b>Specify Components </b> - By studying the software design, the designers segregate the entire system into smaller components or sub-systems. One  complete software design turns into a collection of a huge set of components working together.</p></li>
    <li><p><b>Search Suitable Components</b> - The software component repository is referred by designers to search for the matching component, on the basis of functionality and intended software requirements..</p></li>
    <li><p><b>Incorporate Components</b> - All matched components are packed together to shape them as complete software.</p></li>
    </ul>
    </div>
    
</body>
</html>       