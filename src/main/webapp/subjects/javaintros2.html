<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
</head>
<body>
    <h1>Java Object-Oriented Programming (OOP)</h1>

    <p><strong>Object-Oriented Programming (OOP)</strong> is a programming paradigm used in Java that is based on the concept of objects. In OOP, programs are organized into classes and objects, allowing you to model real-world entities and their interactions in a structured and modular way.</p>

    <h2>Key Concepts in Java OOP:</h2>
    <p>Here are some key concepts and principles of Java OOP:</p>

    <ul>
        <li><strong>Class:</strong> A class is a blueprint or template for creating objects. It defines the properties (attributes) and behaviors (methods) that objects of that class will have.</li>
        <li><strong>Object:</strong> An object is an instance of a class. It represents a real-world entity and encapsulates its data (attributes) and behavior (methods).</li>
        <li><strong>Encapsulation:</strong> Encapsulation is the principle of bundling data (attributes) and methods (functions) that operate on that data into a single unit called an object. It restricts access to the internal state of an object and provides control over its manipulation.</li>
        <li><strong>Inheritance:</strong> Inheritance is a mechanism that allows one class to inherit the properties and behaviors of another class. It promotes code reuse and the creation of hierarchies of classes.</li>
        <li><strong>Polymorphism:</strong> Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables method overriding and dynamic method dispatch, facilitating flexibility in code design and execution.</li>
        <li><strong>Abstraction:</strong> Abstraction is the process of simplifying complex systems by modeling classes based on their essential characteristics and ignoring unnecessary details. It helps in managing complexity and focusing on what's essential.</li>
    </ul>

    <h2>Example of Java OOP:</h2>
    <pre>
        <code>
// Defining a simple Java class
class Car {
    // Instance variables (attributes)
    String brand;
    String model;
    int year;

    // Constructor
    public Car(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }

    // Method to display car information
    public void displayInfo() {
        System.out.println("Brand: " + brand);
        System.out.println("Model: " + model);
        System.out.println("Year: " + year);
    }
}

public class Main {
    public static void main(String[] args) {
        // Creating objects of the Car class
        Car car1 = new Car("Toyota", "Camry", 2022);
        Car car2 = new Car("Honda", "Civic", 2021);

        // Calling methods on objects
        car1.displayInfo();
        car2.displayInfo();
    }
}
        </code>
    </pre>

    <h2>Explanation:</h2>
    <p>In this example, we define a class `Car` with attributes (`brand`, `model`, `year`) and a method (`displayInfo`) to display car information. We create two `Car` objects and call the `displayInfo` method on each object.</p>

    <h2>Notes:</h2>
    <ul>
        <li>OOP promotes modularity, reusability, and easier maintenance of code.</li>
        <li>Java is known for its strong support for OOP concepts, making it suitable for building complex and scalable applications.</li>
        <li>Java supports multiple classes and objects, enabling you to model real-world systems in a structured manner.</li>
    </ul>

  <hr>
    <h1>Java Class Attributes</h1>
    <table>
        <tr>
            <th>Class Name</th>
            <td>Person</td>
        </tr>
        <tr>
            <th>Attributes</th>
            <td>
                <p><strong>Name:</strong> The name of the person.</p>
                <p><strong>Age:</strong> The age of the person.</p>
                <p><strong>Email:</strong> The email address of the person.</p>
            </td>
        </tr>
    </table>

    <table>
        <tr>
            <th>Class Name</th>
            <td>Book</td>
        </tr>
        <tr>
            <th>Attributes</th>
            <td>
                <p><strong>Title:</strong> The title of the book.</p>
                <p><strong>Author:</strong> The author of the book.</p>
                <p><strong>ISBN:</strong> The ISBN of the book.</p>
            </td>
        </tr>
    </table>
<hr>
    <h1>Java Class Methods</h1>
    <table>
        <tr>
            <th>Class Name</th>
            <td>Person</td>
        </tr>
        <tr>
            <th>Methods</th>
            <td>
                <p><strong>setName(String name):</strong> Sets the name of the person.</p>
                <p><strong>setAge(int age):</strong> Sets the age of the person.</p>
                <p><strong>setEmail(String email):</strong> Sets the email address of the person.</p>
                <p><strong>getName():</strong> Returns the name of the person.</p>
                <p><strong>getAge():</strong> Returns the age of the person.</p>
                <p><strong>getEmail():</strong> Returns the email address of the person.</p>
            </td>
        </tr>
    </table>

    <table>
        <tr>
            <th>Class Name</th>
            <td>Book</td>
        </tr>
        <tr>
            <th>Methods</th>
            <td>
                <p><strong>setTitle(String title):</strong> Sets the title of the book.</p>
                <p><strong>setAuthor(String author):</strong> Sets the author of the book.</p>
                <p><strong>setISBN(String isbn):</strong> Sets the ISBN of the book.</p>
                <p><strong>getTitle():</strong> Returns the title of the book.</p>
                <p><strong>getAuthor():</strong> Returns the author of the book.</p>
                <p><strong>getISBN():</strong> Returns the ISBN of the book.</p>
            </td>
        </tr>
    </table>

    <!-- Add more tables for other Java classes and their methods -->

<hr>
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Java Constructor Description</title>
</head>
<body>
    <h1>Java Constructor: <code>ClassName</code></h1>
    
    <h2>Description</h2>
    <p>
        Provide a brief description of the Java constructor here. Explain its purpose and what it initializes in plain language.
    </p>
    
    <h2>Syntax</h2>
    <pre>
        <code>
public ClassName(parameterType1 parameterName1, parameterType2 parameterName2, ...) {
    // Constructor implementation goes here
}
        </code>
    </pre>
    
    <h2>Parameters</h2>
    <ul>
        <li>
            <code>parameterName1</code> (<code>parameterType1</code>) - Description of the first constructor parameter.
        </li>
        <li>
            <code>parameterName2</code> (<code>parameterType2</code>) - Description of the second constructor parameter.
        </li>
        <!-- Add more parameter descriptions as needed -->
    </ul>
    
    <h2>Initialization</h2>
    <p>
        Explain what the constructor initializes and how it does so.
    </p>
    
    <h2>Example</h2>
    <pre>
        <code>
// Example code demonstrating how to create an object using the constructor
public static void main(String[] args) {
    ClassName object = new ClassName(parameterValue1, parameterValue2, ...);
    // Additional code using the object
}
        </code>
    </pre>
</body>
</html>
<hr>

    <h2>Description</h2>
    <p>
        Provide a brief description of the Java constructor here. Explain its purpose and what it initializes in plain language.
    </p>
    
    <h2>Syntax</h2>
    <pre>
        <code>
public ClassName(parameterType1 parameterName1, parameterType2 parameterName2, ...) {
    // Constructor implementation goes here
}
        </code>
    </pre>
    
    <h2>Parameters</h2>
    <ul>
        <li>
            <code>parameterName1</code> (<code>parameterType1</code>) - Description of the first constructor parameter.
        </li>
        <li>
            <code>parameterName2</code> (<code>parameterType2</code>) - Description of the second constructor parameter.
        </li>
        <!-- Add more parameter descriptions as needed -->
    </ul>
    
    <h2>Initialization</h2>
    <p>
        Explain what the constructor initializes and how it does so.
    </p>
    
    <h2>Example</h2>
    <pre>
        <code>
// Example code demonstrating how to create an object using the constructor
public static void main(String[] args) {
    ClassName object = new ClassName(parameterValue1, parameterValue2, ...);
    // Additional code using the object
}
        </code>
    </pre>
<hr>

    <h1>Java Constructor: <code>ClassName</code></h1>
    
    <h2>Description</h2>
    <p>
        Provide a brief description of the Java constructor here. Explain its purpose and what it initializes in plain language.
    </p>
    
    <h2>Syntax</h2>
    <pre>
        <code>
public ClassName(parameterType1 parameterName1, parameterType2 parameterName2, ...) {
    // Constructor implementation goes here
}
        </code>
    </pre>
    
    <h2>Parameters</h2>
    <ul>
        <li>
            <code>parameterName1</code> (<code>parameterType1</code>) - Description of the first constructor parameter.
        </li>
        <li>
            <code>parameterName2</code> (<code>parameterType2</code>) - Description of the second constructor parameter.
        </li>
        <!-- Add more parameter descriptions as needed -->
    </ul>
    
    <h2>Initialization</h2>
    <p>
        Explain what the constructor initializes and how it does so.
    </p>
    
    <h2>Example</h2>
    <pre>
        <code>
// Example code demonstrating how to create an object using the constructor
public static void main(String[] args) {
    ClassName object = new ClassName(parameterValue1, parameterValue2, ...);
    // Additional code using the object
}
        </code>
    </pre>
<hr>
    <h1>Java Encapsulation</h1>
    
    <p>
        Encapsulation is one of the core principles of object-oriented programming (OOP) in Java. It involves bundling an object's data (attributes) and methods (functions) that operate on the data into a single unit called a class. The key concept of encapsulation is to restrict access to the internal state of an object and provide controlled access through methods. This helps in achieving data hiding and protects the integrity of the object.
    </p>
    
    <h2>Benefits of Encapsulation</h2>
    <ul>
        <li><strong>Data Hiding:</strong> Encapsulation hides the internal details and data of an object from the outside world. This prevents unauthorized access and modification of object state.</li>
        <li><strong>Modularity:</strong> Encapsulation promotes modularity by organizing code into self-contained classes, making it easier to understand and maintain.</li>
        <li><strong>Flexibility:</strong> By providing controlled access to data through methods, encapsulation allows for flexibility in modifying the internal implementation of a class without affecting other parts of the code that use the class.</li>
        <li><strong>Security:</strong> Encapsulation enhances security by ensuring that only authorized methods can access and modify the object's data, preventing unintended data corruption.</li>
    </ul>
    
    <h2>How Encapsulation Works</h2>
    <p>
        In Java, encapsulation is achieved by defining class members (fields or variables) as <code>private</code> and providing <code>public</code> methods (getters and setters) to access and modify these fields. The getter methods retrieve the values of private fields, and setter methods allow controlled modification.
    </p>
    
    <h2>Example</h2>
    <p>
        Here is a simple example demonstrating encapsulation in Java:
    </p>
    <pre>
        <code>
public class Person {
    private String name; // Private field
    
    // Getter method to access the name field
    public String getName() {
        return name;
    }
    
    // Setter method to modify the name field
    public void setName(String newName) {
        name = newName;
    }
}
        </code>
    </pre>
    <p>
        In the above example, the <code>name</code> field is encapsulated and can only be accessed or modified through the <code>getName()</code> and <code>setName()</code> methods, respectively.
    </p>
<hr>
    <h1>Java Packages and APIs</h1>
    
    <p>
        In Java, packages and APIs play a crucial role in organizing and providing access to classes and libraries. Understanding how packages and APIs work is essential for effective Java development.
    </p>
    
    <h2>Packages</h2>
    <p>
        A package in Java is a way to organize related classes and interfaces into a single namespace. It helps prevent naming conflicts and provides a structured hierarchy for your code. Packages are defined using the <code>package</code> keyword at the beginning of a Java source file.
    </p>
    <p>
        Packages are organized in a hierarchical manner, with a top-level package and sub-packages beneath it. For example:
    </p>
    <pre>
        <code>
package com.example.myapp; // Top-level package

public class MyClass {
    // Class implementation goes here
}
        </code>
    </pre>
    <p>
        In this example, <code>com.example.myapp</code> is a top-level package, and <code>MyClass</code> is part of it. Packages help in managing and organizing your codebase.
    </p>
    
    <h2>APIs (Application Programming Interfaces)</h2>
    <p>
        APIs in Java refer to the set of classes, interfaces, and methods provided by the Java standard library or third-party libraries for performing various tasks. These APIs allow developers to leverage pre-built functionality in their applications without reinventing the wheel.
    </p>
    <p>
        Some commonly used Java APIs include:
    </p>
    <ul>
        <li><strong>java.lang:</strong> Contains fundamental classes and types, including <code>String</code>, <code>Object</code>, and <code>Math</code>.</li>
        <li><strong>java.util:</strong> Provides data structures and utility classes, such as <code>ArrayList</code>, <code>HashMap</code>, and <code>Date</code>.</li>
        <li><strong>java.io:</strong> Offers classes for input and output operations, like <code>FileInputStream</code>, <code>FileOutputStream</code>, and <code>BufferedReader</code>.</li>
        <li><strong>javax.swing:</strong> Supports building graphical user interfaces (GUIs) with classes like <code>JFrame</code> and <code>JButton</code>.</li>
        <li><strong>Third-party APIs:</strong> Developers can also use APIs provided by third-party libraries and frameworks to extend Java's capabilities for specific tasks.</li>
    </ul>
    
    <h2>Importing Classes and Using APIs</h2>
    <p>
        To use classes and interfaces from packages and APIs, you need to import them into your Java code using the <code>import</code> statement. For example:
    </p>
    <pre>
        <code>
import java.util.ArrayList; // Importing ArrayList class from java.util package

public class MyApp {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; myList = new ArrayList&lt;&gt;();
        // Use ArrayList methods here
    }
}
        </code>
    </pre>
    <p>
        In this example, we import the <code>ArrayList</code> class from the <code>java.util</code> package and use it in our <code>MyApp</code> class.
    </p>
<hr>
    <h1>Java Inheritance</h1>
    
    <p>
        Inheritance is a core concept in Java and object-oriented programming (OOP). It allows you to create a new class based on an existing class, known as the superclass or parent class. The new class is called the subclass or child class. Inheritance enables you to reuse and extend the functionality of existing classes, promoting code reuse and organization.
    </p>
    
    <h2>Key Concepts</h2>
    <ul>
        <li><strong>Superclass (Parent Class):</strong> The class whose properties and behaviors are inherited by another class.</li>
        <li><strong>Subclass (Child Class):</strong> The class that inherits properties and behaviors from a superclass and may add its own unique properties and behaviors.</li>
        <li><strong>Extends Keyword:</strong> In Java, you use the <code>extends</code> keyword to create a subclass that inherits from a superclass. For example:
            <pre>
                <code>
class ParentClass {
    // Superclass implementation
}

class ChildClass extends ParentClass {
    // Subclass implementation
}
                </code>
            </pre>
        </li>
        <li><strong>Method Overriding:</strong> Subclasses can provide their own implementations of methods inherited from a superclass. This is known as method overriding. It allows a subclass to customize the behavior of inherited methods. Example:
            <pre>
                <code>
class Animal {
    void makeSound() {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }
}
                </code>
            </pre>
        </li>
        <li><strong>Access Modifiers:</strong> Access modifiers (e.g., <code>public</code>, <code>private</code>, <code>protected</code>) control the visibility of superclass members in subclasses. Subclasses can access public and protected members of the superclass. Private members are not accessible in subclasses.</li>
    </ul>
    
    <h2>Example</h2>
    <p>
        Here's a simple example demonstrating inheritance in Java:
    </p>
    <pre>
        <code>
class Shape {
    protected double area;

    public void calculateArea() {
        // Calculation logic (e.g., for a generic shape)
    }
}

class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public void calculateArea() {
        area = Math.PI * radius * radius;
    }
}
        </code>
    </pre>
    <p>
        In this example, the <code>Circle</code> class inherits the <code>calculateArea()</code> method from the <code>Shape</code> superclass and provides its own implementation to calculate the area for a circle.
    </p>
<hr>

    <h1>Java Polymorphism</h1>
    
    <p>
        Polymorphism is a fundamental concept in Java and object-oriented programming (OOP). It allows you to treat objects of different classes as objects of a common superclass. This enables flexibility in method calls, as the actual method to be executed is determined at runtime, based on the type of the object.
    </p>
    
    <h2>Key Concepts</h2>
    <ul>
        <li><strong>Polymorphism:</strong> The ability of different objects to respond to the same method invocation in their own unique way.</li>
        <li><strong>Superclass and Subclasses:</strong> Polymorphism typically involves a superclass (or interface) and multiple subclasses. Subclasses inherit and override methods from the superclass.</li>
        <li><strong>Method Overriding:</strong> In polymorphism, subclasses provide their own implementation (override) for methods defined in the superclass. The overridden method in the subclass has the same name, return type, and parameters as the method in the superclass.</li>
        <li><strong>Dynamic Method Dispatch:</strong> At runtime, the Java Virtual Machine (JVM) determines which version of an overridden method to execute based on the actual type of the object, not the reference type.</li>
        <li><strong>Use of the <code>super</code> Keyword:</strong> The <code>super</code> keyword is used to call the overridden method from the superclass within a subclass's overridden method.</li>
    </ul>
    
    <h2>Example</h2>
    <p>
        Here's a simple example demonstrating polymorphism in Java:
    </p>
    <pre>
        <code>
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Cat meows");
    }
}

public class PolymorphismExample {
    public static void main(String[] args) {
        Animal myAnimal1 = new Dog();
        Animal myAnimal2 = new Cat();
        
        myAnimal1.makeSound(); // Calls Dog's makeSound() method
        myAnimal2.makeSound(); // Calls Cat's makeSound() method
    }
}
        </code>
    </pre>
    <p>
        In this example, both <code>Dog</code> and <code>Cat</code> are subclasses of <code>Animal</code>. Despite having references of type <code>Animal</code>, the actual methods called are determined at runtime, resulting in polymorphic behavior.
    </p>
<hr>
    <h1>Java Inheritance</h1>
    
    <p>
        Inheritance is a fundamental concept in Java and object-oriented programming (OOP). It allows you to create a new class, called a subclass or derived class, based on an existing class, called a superclass or base class. The subclass inherits the properties (fields) and behaviors (methods) of the superclass. Inheritance promotes code reuse, extensibility, and hierarchical organization of classes.
    </p>
    
    <h2>Key Concepts</h2>
    <ul>
        <li><strong>Superclass (Base Class):</strong> The class whose properties and behaviors are inherited by another class.</li>
        <li><strong>Subclass (Derived Class):</strong> The class that inherits properties and behaviors from a superclass and may add its own unique properties and behaviors.</li>
        <li><strong>Extends Keyword:</strong> In Java, you use the <code>extends</code> keyword to create a subclass that inherits from a superclass. For example:
            <pre>
                <code>
class Animal {
    String name;
    
    void eat() {
        // Implementation for eating behavior
    }
}

class Dog extends Animal {
    String breed;
    
    void bark() {
        // Implementation for barking behavior
    }
                </code>
            </pre>
        </li>
        <li><strong>Method Overriding:</strong> Subclasses can provide their own implementations of methods inherited from a superclass. This is known as method overriding. It allows a subclass to customize the behavior of inherited methods. Example:
            <pre>
                <code>
class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Dog barks");
    }
}
                </code>
            </pre>
        </li>
        <li><strong>Access Modifiers:</strong> Access modifiers (e.g., <code>public</code>, <code>private</code>, <code>protected</code>) control the visibility of superclass members in subclasses. Subclasses can access public and protected members of the superclass. Private members are not accessible in subclasses.</li>
    </ul>
    
    <h2>Example</h2>
    <p>
        Here's a simple example demonstrating inheritance in Java:
    </p>
    <pre>
        <code>
class Shape {
    protected double area;
    
    void calculateArea() {
        // Calculation logic for area
    }
}

class Circle extends Shape {
    private double radius;
    
    Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    void calculateArea() {
        area = Math.PI * radius * radius;
    }
}
        </code>
    </pre>
    <p>
        In this example, the <code>Circle</code> class inherits the <code>calculateArea()</code> method from the <code>Shape</code> superclass and provides its own implementation to calculate the area for a circle.
    </p>

<hr>
    <h1>Java Threads</h1>
    
    <p>
        Threads are a fundamental concept in Java and are used to achieve multithreading, allowing multiple tasks to run concurrently within a single program. Threads enable you to efficiently utilize the processing power of modern computers and create responsive applications.
    </p>
    
    <h2>Key Concepts</h2>
    <ul>
        <li><strong>Thread:</strong> A thread is the smallest unit of execution within a Java program. It represents an independent path of execution and allows tasks to run concurrently.</li>
        <li><strong>Thread Class:</strong> Java provides the <code>Thread</code> class to create and manage threads. You can create a thread by extending the <code>Thread</code> class or implementing the <code>Runnable</code> interface.</li>
        <li><strong>Multithreading:</strong> Multithreading is the practice of running multiple threads within a single process. It enables better utilization of CPU resources and can improve the performance of applications.</li>
        <li><strong>Thread States:</strong> Threads can be in various states, including <code>NEW</code>, <code>RUNNABLE</code>, <code>BLOCKED</code>, <code>WAITING</code>, <code>TIMED_WAITING</code>, and <code>TERMINATED</code>, depending on their current activities.</li>
        <li><strong>Thread Synchronization:</strong> When multiple threads access shared resources concurrently, synchronization mechanisms like <code>synchronized</code> blocks and locks are used to prevent race conditions and ensure data consistency.</li>
        <li><strong>Thread Priority:</strong> Threads can have priority levels (from 1 to 10), where higher-priority threads are scheduled to run before lower-priority threads. However, thread priority is platform-dependent and may not have a significant impact on performance in all cases.</li>
    </ul>
    
    <h2>Example</h2>
    <p>
        Here's a simple example demonstrating the creation and execution of threads in Java:
    </p>
    <pre>
        <code>
class MyThread extends Thread {
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println("Thread " + getId() + " - Count: " + i);
        }
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();
        
        thread1.start(); // Start the first thread
        thread2.start(); // Start the second thread
    }
}
        </code>
    </pre>
    <p>
        In this example, two threads (<code>thread1</code> and <code>thread2</code>) are created by extending the <code>Thread</code> class. They run concurrently, printing counts from 1 to 5.
    </p>
<hr>
    <h1>Java Lambda Expressions</h1>
    
    <p>
        Lambda expressions, introduced in Java 8, provide a concise way to express instances of single-method interfaces (functional interfaces) using a more compact syntax. They allow you to treat functionality as a method argument or code as data, enabling functional-style programming in Java.
    </p>
    
    <h2>Key Concepts</h2>
    <ul>
        <li><strong>Lambda Expression:</strong> A lambda expression is a lightweight, anonymous function that can be used to create instances of functional interfaces. It consists of a parameter list, an arrow (<code>-&gt;</code>), and a body that represents the method implementation.</li>
        <li><strong>Functional Interface:</strong> A functional interface is an interface that defines only one abstract method. Lambda expressions can be used to provide an implementation for this single method.</li>
        <li><strong>Syntax:</strong> Lambda expressions follow the syntax: <code>(parameter1, parameter2, ...) -&gt; expression</code>. For example:
            <pre>
                <code>
// Lambda expression to square a number
(int x) -&gt; x * x
                </code>
            </pre>
        </li>
        <li><strong>Functional Interfaces in Java:</strong> Java provides several built-in functional interfaces in the <code>java.util.function</code> package, including <code>Consumer</code>, <code>Predicate</code>, <code>Function</code>, and more.</li>
        <li><strong>Method References:</strong> In addition to lambda expressions, Java 8 introduced method references as a way to refer to methods of a class or object using a shorter syntax.</li>
        <li><strong>Benefits:</strong> Lambda expressions make code more concise and readable, particularly when working with collections, streams, and functional programming paradigms.</li>
    </ul>
    
    <h2>Example</h2>
    <p>
        Here's a simple example demonstrating the use of lambda expressions in Java:
    </p>
    <pre>
        <code>
import java.util.ArrayList;
import java.util.List;

public class LambdaExample {
    public static void main(String[] args) {
        List&lt;String&gt; names = new ArrayList&lt;&gt;();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");
        
        // Using a lambda expression to print each name
        names.forEach(name -&gt; System.out.println("Hello, " + name));
    }
}
        </code>
    </pre>
    <p>
        In this example, a lambda expression is used within the <code>forEach</code> method to iterate through a list of names and print a greeting for each.
    </p>







   

</body>
</html>