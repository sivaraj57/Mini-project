<!DOCTYPE html>
<html>
<head>
	
</head>
<body>

	<h1><span class="color_h1" style="color:rgb(76, 27, 97)">INTRODUCTION</span></h1>
	<hr>
	
	<p>An Operating System (OS) acts as an interface connecting a computer user with the computer's hardware. An operating system falls under the category of system software that performs all the fundamental tasks like file management, memory handling, process management, handling the input/output, and governing and managing the peripheral devices like disk drives, networking hardware, printers, etc. Some well-liked Operating Systems are Linux, Windows, OS X, Solaris, OS/400, Chrome OS, etc.</p>
	<hr>
	<h2>Features of Operating System</h2>
	<ol>
        Here is a list of some significant functions of an Operating System, which is found common in almost all operating systems:<br><br>

        <li><i><u><b>Resource management:</b></u></i> Operating systems manage the computer's resources, such as its memory, processor, and storage, and allocate them to different tasks as needed.</li><br>
        <li><i><u><b>Memory management:</b></u></i> Operating systems manage the computer's memory and ensure that each program or process has access to the memory it needs to run.</li><br>
        <li><i><u><b>Process management:</b></u></i> Operating systems create and manage processes, which are units of work executed by the computer.</li><br>
        <li><i><u><b>File management:</b></u></i> Operating systems manage the files on the computer, including organizing them and providing access for different programs and users.</li><br>
        <li><i><u><b>Security: </b></u></i>Operating systems include security features to protect the computer from unauthorized access and viruses.</li><br>
        <li><i><u><b>User interface:</b></u></i> Operating systems provide an interface for users to interact with the computer, such as through a graphical user interface (GUI) or command-line interface (CLI).</li><br>
        <li><i><u><b>Networking:</b></u></i> Many operating systems include support for networking, allowing the computer to communicate and exchange data with other devices over a network, such as the internet or a local area network (LAN).</li><br>
        <li><i><u><b>Device management:</b></u></i> Operating systems manage the devices connected to the computer, such as printers, keyboards, and storage devices.</li><br>
        <li><i><u><b>Power management:</b></u></i> Operating systems include features to manage the power usage of the computer and conserve energy when possible.</li><br>
        <li><i><u><b>Software installation and updates: </b></u></i>Operating systems provide a mechanism for installing and updating software applications.
        These are just a few examples of features commonly found in operating systems. The specific features of an operating system depend on the particular system and its intended use.</li><br>
    </ol>
    <hr>
    <h2>Objectives of Operating System</h2>
	<ul>
        An operating system consists of unique programs that control the execution of software. The OS acts as an intermediary between applications and hardware components. OS can be thought of as having three objectives. These are:<br><br>

        <li><i><u><b>Convenience:</b></u></i> It makes a computer more suitable to use.</li><br>
        <li><i><u><b>Efficiency:</b></u></i> It provides the computer system resources with efficiency and in easy to use format.</li><br>
        <li><i><u><b>Ability to develop:</b></u></i> It should be built in such a way that it permits the efficient development, testing, and installation of new system functions without interfering with service.
        </li><br>
        
    </ul>
    <hr>
   
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">BASIC ELEMENTS OF A COMPUTER SYSTEM</span></h1>
    <hr>
    <p>At an upper level of any computer architecture, a computer is supposed to have a processor, memory, and some I/O components, with one or more quantities of each type. These components are interrelated and connected in a way to achieve the significant function of the computer, which is to execute programs.</p>
	
	<ol>
        There are four key structural elements of any computer. These are:<br><br>

        <li><i><u><b>Processor:</b></u></i>  It controls the processes within the computer and carries out its data processing functions. When there is only one processor available, it is in combination termed as the central processing unit (CPU), which you must be familiar with.</li><br>
        <li><i><u><b>Main memory:</b></u></i>  It stores data and programs within it. This memory is typically volatile and is also called primary memory. This is because when the computer is shut down, the contents within the memory get lost. In contrast, the contents of disk memory are kept hold of even when the computer system is turned off, which you call a shutting down of the Operating system or computer. Main memory is also termed real memory.</li><br>
        <li><i><u><b>Input/Output (I/O) devices:</b></u></i>This moves the data within the computer to its peripheral external environment. The external environment is supposed to have a variety of devices, including secondary memory devices (e.g., pen drives, CDs, etc.), communications equipment (such as LAN cable), terminals, etc.</li><br>
        <li><i><u><b>System bus:</b></u></i>  It provides communication between processors, main memory, and I/O modules.</li><br>
        <p>These are some of the essential elements of a computer system. There may be other components, depending on the specific design and configuration of the system.</p>
        
    </ol>
    <hr>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">SERVICES</span></h1>
	<hr>	
	<p>An Operating System supplies different kinds of services to both the users and to the programs as well. It also provides application programs (that run within an Operating system) an environment to execute it freely. It provides users the services run various programs in a convenient manner.</p>
	Here is a list of common services offered by an almost all operating systems:
    <ul>
        <li>User Interface</li>
        <li>Program Execution</li>
        <li>File system manipulation</li>
        <li>Input / Output Operations</li>
        <li>Communication</li>
        <li>Resource Allocation</li>
        <li>Error Detection</li>
        <li>Accounting</li>
        <li>Security and protection</li>
    </ul>   
        This chapter will give a brief description of what services an operating system usually provide to users and those programs that are and will be running within it.
    <hr>
    <h2>User Interface of Operating System</h2>
    <p>Usually Operating system comes in three forms or types. Depending on the interface their types have been further subdivided. These are:</p>
    <ul>
        <li>Command line interface</li>
        <li>Batch based interface</li>
        <li>Graphical user interface</li>
    </ul>
    <p>Let's get to know in brief about each of them.<br><br>

        The command line interface (CLI) usually deals with using text commands and a technique for entering those commands. The batch interface (BI): commands and directives are used to manage those commands that are entered into files and those files get executed. Another type is the graphical user interface (GUI): which is a window system with a pointing device (like mouse or trackball) to point to the I/O, choose from menus driven interface and to make choices viewing from a number of lists and a keyboard to entry the texts.
    </p>
    <hr>
    <h2>Program Execution in Operating System</h2>
    <p>The operating system must have the capability to load a program into memory and execute that program. Furthermore, the program must be able to end its execution, either normally or abnormally / forcefully.
    </p>
    <hr>
    <h2>File System Manipulation in Operating System</h2>
    <p>Programs need has to be read and then write them as files and directories. File handling portion of operating system also allows users to create and delete files by specific name along with extension, search for a given file and / or list file information. Some programs comprise of permissions management for allowing or denying access to files or directories based on file ownership.
    </p>
    <hr>
    <h2>I/O Operations in Operating System</h2>
    <p>A program which is currently executing may require I/O, which may involve file or other I/O device. For efficiency and protection, users cannot directly govern the I/O devices. So, the OS provide a means to do I/O Input / Output operation which means read or write operation with any file.</p>
    <hr>
    <h2>Communication System of Operating System</h2>
    <p>Process needs to swap over information with other process. Processes executing on same computer system or on different computer systems can communicate using operating system support. Communication between two processes can be done using shared memory or via message passing.
    </p>
    <hr>
    <h2>Resource Allocation of Operating System</h2>
    <p>When multiple jobs running concurrently,  resources must need to be allocated to each of them. Resources can be CPU cycles, main memory storage, file storage and I/O devices. CPU scheduling routines are used here to establish how best the CPU can be used.
    </p>
    <hr>
    <h2>Error Detection</h2>
    <p>Errors may occur within CPU, memory hardware, I/O devices and in the user program. For each type of error, the OS takes adequate action for ensuring correct and consistent computing.
    </p>
    <hr>
    <h2>Accounting</h2>
    <p>This service of the operating system keeps track of which users are using how much and what kinds of computer resources have been used for accounting or simply to accumulate usage statistics.</p>
    <hr>
    <h2>Protection and Security</h2>
    <p>Protection includes in ensuring all access to system resources in a controlled manner. For making a system secure, the user needs to authenticate him or her to the system before using (usually via login ID and password).</p>
    <hr>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">PROPERTIES</span></h1>
	<hr>
	
	<p>In this chapter, you will learn about the general structure of functionalities and properties that the operating system provides for a typical computer system. A computer system may be organized in a number of different ways, which you can categorize roughly according to the number of general-purpose processors used.  </p>
    <hr>
    <h2>Single Processor Systems</h2>
    <p>Most systems at least contain a single processor. The variation of single-processor systems may be unexpected, but since these systems can range from PDA's to mainframe computers. On a single-processor system, there is one main CPU able to execute a general-purpose instruction layout, including different instructions from users and then process them. Almost every system has special-purpose processors within them. They may come in the appearance of device-specific processors, such as disks, keyboards, graphics controllers, etc.; or on mainframes, they may come in the form of more general-purpose processors.</p>
    <hr>
    <h2>Batch Processing</h2>
    <p>Batch processing is a method where an operating system gathers different programs along with the data together in a batch before starting the process. An operating system does the below-mentioned activities to perform batch related processing:
        <ul>
            <li>The operating system identifies a job or sets of jobs that are further assigned to a sequence of commands, programs, and data within a single unit.</li>
            <li>The operating system maintains the lists of number jobs in memory. It then executes them one by one based on some scheduling algorithm.</li>
            <li>Most of the jobs In operating system are processed in the order they have been submitted, i.e., first come first serve (FCFS) manner.</li>
        </ul>
    </p>
    <hr>
    <h2>Multiprogramming Property of Operating System</h2>
    <p>Multi-programmed structure or mechanism provides an environment where a variety of system resources like memory, CPU, and various peripheral devices gets utilized efficiently, but they do not offer for user interaction with the computer system. Time-sharing which is also called multitasking is a logical extension or enhancement of the term multiprogramming.</p>
    <p>In time-sharing systems, the processor is given multiple tasks by switching among them, but the switches take place so frequently that the users can work together with each and every program while it is running and it seems that all of the programs are running simultaneously. Time-sharing needs an interactive computer structure that allows direct communication between the user and the system.</p>
    <hr>
    <h2>Multiprogramming in Operating System</h2>
    <p>A single user cannot keep either the processor or the Input / Output devices busy every time. The concept of multiprogramming is implemented to amplify CPU utilization by managing jobs so that the CPU always has at least one job to execute.</p>
    <p>Sharing the processor, when multiple programs reside in memory at a single time, is termed as multi-programming. Multi-programming takes for granted a single shared processor for one or more tasks.    </p>
    <hr>
    <h2>Clustered System in OS</h2>
    <p>Another type of multiple - CPU concept is the clustered structured system. Like multi-processing, clustered systems collect together several CPUs to achieve the better computational job. Clustered systems vary from multiprocessor systems, but in the same time, they are composed of two or multiple individual systems that are coupled as a single unit.    </p>
    <hr>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">PROCESS MANAGEMENT</span></h1>
	<hr>
	
	<p>During the olden days, computer systems allowed only one program to be executed at one time. This is why that program had complete power of the system and had access to all or most of the system's resources. In contrast, nowadays, current-day computer systems let multiple programs to be loaded into memory and execute them concurrently. This massive change and development required rigid control and more compartmentalization in various programs.</p>
    <p>The more fused or complex the operating system is, the more it is expected to do on behalf of its users. Even though its main concern is the execution of user programs, it also requires taking care of various system tasks which are better left outside the kernel itself. So a system must consist of a set of processes: operating system processes, executing different system code and user processes which will be executing user code. In this chapter, you will learn about the processes that are being used and managed by the operating system.</p>
    <hr>
    <h2>What are the processors?</h2>
    <p>A process is mainly a program in execution where the execution of a process must progress in sequential order or based on some priority or algorithms. In other words, it is an entity that represents the fundamental working that has been assigned to a system.</p>
    <p>When a program gets loaded into the memory, it is said to as a process. This processing can be categorized into four sections. These are:</p>
    <ul>
        <li>Heap</li>
        <li>Stack</li>
        <li>Data</li>
        <li>Text</li>
    </ul>
    <hr>
    <h2>Process Concept</h2>
    <p>There's a question which arises while discussing operating systems that involves when to call all the activities of the CPU. Even on a single-user operating system like Microsoft Windows, a user may be capable of running more than a few programs at one time like MS Word processor, different web browser(s) and an e-mail messenger. Even when the user can execute only one program at a time, the operating system might require maintaining its internal programmed activities like memory management. In these respects, all such activities are similar, so we call all of them as 'processes.'</p>
    <p>Again another term - "job" and process are used roughly replacing each other. Much of the operating - system theory and terminology was developed during a time when the main action of operating systems was job processing; so the term job became famous gradually. It would be confusing to avoid the use of commonly accepted terms which include the word job like 'job scheduling.'    </p>
    <hr>
    <h2>Process state of OS</h2>
    <p>As a process executes, it changes state. The state of a process is defined in part by the current activity of that process. Each process may be in one of the following states:</p>
    <ul>
        <li><i><u><b>New:</b></u></i>In this state, the process is being created.</li><br>
        <li><i><u><b>Running:</b></u></i> In this state, instructions are being executed.</li><br>
        <li><i><u><b>Waiting:</b>:</b></u></i> In this state, the process is waiting for the different event to occur like I/O completion or treatment of a signal.</li><br>
        <li><i><u><b>Ready:</b></u></i> In this state, the process waits to assign a processor.</li><br>
        <li><i><u><b>Terminated:</b></u></i>In this state, the process has finished executing.</li><br>
    </ul>
    <hr>
    <h1><span class="color_h1" style="color:rgb(76, 27, 97)">THREADS</span></h1>
	
	<hr>
	<p>The process model that has been discussed in previous tutorials described that a process was an executable program that is having a single thread of control. The majority of the modern operating systems now offer features enabling a process for containing multiple threads of control. In this tutorial, there are many concepts associated with multithreaded computer structures. There are many issues related to multithreaded programming and how it brings effect on the design of any operating systems. Then you will learn about how the Windows XP and Linux OS maintain threads at the kernel level.</p>
    <hr>
    <h2>What is a thread?</h2>
    <p>A thread is a stream of execution throughout the process code having its program counter which keeps track of lists of instruction to execute next, system registers which bind its current working variables. Threads are also termed as lightweight process. A thread uses parallelism which provides a way to improve application performance.</p>
    <hr>
    <h2>Major Types of Threads</h2>
    <p>Let us take an example where a web browser may have one thread to display images or text while another thread retrieves data from the network. Another example can be a word processor that may have a thread for displaying the UI or graphics while a new thread for responding to keystrokes received from the user and another thread is to perform spelling and grammar checking in the background. In some cases, a single application may be required to perform several similar tasks.</p>
    <hr>
    <h2>Advantages of Threads in OS</h2>
    <p>The advantages of multithreaded programming can be categorized into four major headings -
        <ul>
            <li><i><u><b>Responsiveness:</b></u></i> Multithreading is an interactive concept for an application which may allow a program to continue running even when a part of it is blocked or is carrying a lengthy operation, which increases responsiveness to the user.</li>
            <li><i><u><b>Resource Sharing:</b></u></i> Mostly threads share the memory and the resources of any process to which they fit in. The advantage of sharing code is that it allows any application to have multiple different threads of activity inside the same address space.</li>
            <li><i><u><b>Economy:</b></u></i>In OS, allocation of memory and resources for process creation seems costly. Because threads can distribute resources of any process to which they belong, it became more economical to create and develop context-switch threads.</li>
            <li><i><u><b>Utilization of multiprocessor architectures:</b></u></i> The advantages of multithreading can be greatly amplified in a multiprocessor architecture, where there exist threads which may run in parallel on diverse processors.</li>
        </ul>
        <hr>
        <h2>Multithreading Models</h2>
        <p>All the threads must have a relationship between them (i.e., user threads and kernel threads). Here is a list which tells the three common ways of establishing this relationship.
            <ul>
                <li><i><u><b>Many-to-One Model: </b></u></i>In the many-to-one model plots several user-level threads to a single kernel thread.</li>
                <li><i><u><b>One-to-One Model: </b></u></i>In the one-to-one model maps every particular user thread to a kernel thread and provides more concurrency compare to many-to-one model.</li>
                <li><i><u><b>Many-to-Many Model: </b></u></i> In the many-to-many model, many user-level threads get mapped to a smaller or equal quantity of kernel threads. The number of kernel threads might be exact to either a particular application or to a particular machine.</li>
            </ul>
            <hr>
        </p>
    </p>
    
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">SCHEDULING TECHNIQUES</span></h1>
	<hr>
    <p>CPU scheduling is the foundation or starting concept of multi-programmed operating systems (OSs). By toggling the CPU with different processes, the operating system can make the computer and its processing power more productive. In this tutorial, you will learn about the introductory basic of CPU-scheduling concepts.</p>
    <hr>
    <h2>What is CPU/Process Scheduling</h2>
    <p>The CPU scheduling is the action done by the process manager to handle the elimination of the running process within the CPU and the inclusion of another process by certain specific strategies.</p>
    <hr>
    <h2>Reason behind the use of CPU Scheduling</h2>
    <p>In a single-processor system, only one job can be processed at a time; rest of the job must wait until the CPU gets free and can be rescheduled. The aim of multiprogramming is to have some process to run at all times, for maximizing CPU utilization. The idea is simple. In this case, the process gets executed until it must wait, normally for the completion of some I/O request.</p>
    <p>In a simple operating system, the CPU then just stands idle. All this waiting time is wasted; no fruitful work can be performed. With multiprogramming, you can use this time to process other jobs productively.</p>
    <hr>
    <h2>CPU-I/O Burst Cycle</h2>
    <p>The success of CPU scheduling varies on an experiential property of processes: Process execution holds a cycle of CPU execution and Input / Output wait. Processes get to swap between these two states. Process execution begins with a burst of CPU. That is followed by an Input / Output burst and goes after by one more CPU burst, then one more Input / Output burst, and it continues. Eventually, the final or last CPU burst finish with a system request for terminating execution.</p>
    <hr>
    <h2>CPU Schedulers</h2>
    <p>Whenever the CPU gets idle, the operating system (OS) has to select one of the processes in the ready queue for execution. The selection process is performed by the short-term scheduler (also known as CPU scheduler). The scheduler picks up a process from the processes in memory which are ready to be executed and allocate the CPU with that process.    </p>
    <hr>
    <h2>Preemptive Scheduling</h2>
    <p>CPU scheduling choices may take place under the following four conditions:
        <ul>
            <li>When a process toggles from the running state to its waiting state</li>
            <li>When a process toggles from the running state to its ready state (an example can be when an interrupt occurs)</li>
            <li>When a process toggles from the waiting state to its ready state (for example, at the completion of Input / Output)</li>
            <li>When a process terminates (example when execution ends)            </li>
        </ul>
        <hr>
    </p>
    
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">SCHEDULING ALGORITHMS</span></h1>
    <hr>
    <p>CPU scheduling treats with the issues of deciding which of the processes in the ready queue needs to be allocated to the CPU. There are several different CPU scheduling algorithms used nowadays within an operating system. In this tutorial, you will get to know about some of them.</p>
    <hr>
    <h2>First-Come, First-Served Scheduling (FCFS) Algorithm</h2>
    <p>By far the easiest and simplest CPU scheduling algorithm is the first-come, first served (FCFS) scheduling technique. With this method, the process which requests the CPU first, that process gets allocated to the CPU first. The execution of the FCFS policy is easily managed with a FIFO queue. As a process enters the ready queue, its Process Control Block is linked with the tail of the queue. When the CPU gets free, it is assigned to the process at the head or start of the queue.</p>
    <p>Consider the following set of processes/jobs which arrive at time 0, with the length of the CPU burst that is given in milliseconds:</p>
    <img src="C:\Users\harsh\Pictures\Screenshots\Screenshot (416).png">
    <p>When the processes arrive in the order - P1, P2, P3 and is served using FCFS method, you get the outcome as given in the below mentioned Gantt chart:</p>
    <img src="C:\Users\harsh\Pictures\Screenshots\s2.png">
    <hr>
    <h2>Shortest-Job-First Scheduling Technique</h2>
    <p>A diverse approach to CPU scheduling is the technique of shortest-job-first (SJF) scheduling algorithm which links with each process the length of the process's next CPU burst. If the CPU is available, it is assigned to the process that has the minimum next CPU burst. If the subsequent CPU bursts of two processes become the same, then FCFS scheduling is used to break the tie.</p>
    <p>Let us take an example of SJF scheduling, with the given set of processes below, and the length of the CPU burst in milliseconds:
        <img src="C:\Users\harsh\Pictures\Screenshots\Screenshot (418).png">
    </p>
    <hr>
    <h2>Priority Scheduling</h2>
    <p>The SJF algorithm is a special example of the common priority scheduling technique. A priority is related and assigned with each process, and the CPU gets assigned to the process with the maximum priority. Equal priority processes get scheduled using FCFS method. An SJF algorithm is purely a priority algorithm wherein the priority (P) is the opposite of the (predicted) subsequent CPU burst. The better the CPU burst, the lower the priority is and vice versa.    </p>
    <hr>
    <h2>Round-Robin Scheduling</h2>
    <p>The round-robin (RR) scheduling technique is intended mainly for time-sharing systems. This algorithm is related to FCFS scheduling, but preemption is included to toggle among processes. A small unit of time which is termed as a time quantum or time slice has to be defined. A 'time quantum' is usually from 10 to 100 milliseconds. The ready queue gets treated with a circular queue. The CPU scheduler goes about the ready queue, allocating the CPU with each process for the time interval which is at least 1-time quantum.</p>
    <hr>
    <h2>Multilevel Queue Scheduling</h2>
    <p>Another form of scheduling technique has been designed for situations where processes are simply classified into different groups. A multi-level queue scheduling technique partitions or divides the ready queue into many separate queues. The processes get permanently assigned to one queue, usually based on some property of the process, such as the size of the memory, process priority and/or type of process. Each queue got its scheduling algorithm which works at the multilevel form.

        Here is the diagram of how it works:
        <img src="C:\Users\harsh\Pictures\Screenshots\Screenshot (419).png">
    </p>
    <hr>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">DEADLOCKS</span></h1>
    <hr>
    <p>In a multiprogramming system, numerous processes get competed for a finite number of resources. Any process requests resources, and as the resources aren't available at that time, the process goes into a waiting state. At times, a waiting process is not at all able again to change its state as other waiting processes detain the resources it has requested. That condition is termed as deadlock. In this chapter, you will learn about this issue briefly in connection with semaphores.    </p>
    <hr>
    <h2>System Model</h2>
    <p>A system model or structure consists of a fixed number of resources to be circulated among some opposing processes. The resources are then partitioned into numerous types, each consisting of some specific quantity of identical instances. Memory space, CPU cycles, directories and files, I/O devices like keyboards, printers and CD-DVD drives are prime examples of resource types. When a system has 2 CPUs, then the resource type CPU got two instances.</p>
    <p>Under the standard mode of operation, any process may use a resource in only the below-mentioned sequence:
        <ol>
            <li><b>Request: </b>When the request can't be approved immediately (where the case may be when another process is utilizing the resource), then the requesting job must remain waited until it can obtain the resource.</li>
            <li><b>Use: </b>The process can run on the resource (like when the resource is a printer, its job/process is to print on the printer).</li>
            <li><b>Release: </b>The process releases the resource (like, terminating or exiting any specific process).</li>
        </ol>
    </p>
    <hr>
    <h2>Necessary Conditions and Preventions for Deadlock</h2>
    <p>
        A deadlock state can occur when the following four circumstances hold simultaneously within a system:
        <ul>
            <li><b>Mutual exclusion: </b>At least there should be one resource that has to be held in a non-sharable manner; i.e., only a single process at a time can utilize the resource. If other process demands that resource, the requesting process must be postponed until the resource gets released.</li>
            <li><b>Hold and wait: </b>A job must be holding at least one single resource and waiting to obtain supplementary resources which are currently being held by several other processes.</li>
            <li><b>No preemption: </b>Resources can't be anticipated; i.e., a resource can get released only willingly by the process holding it, then after that, the process has completed its task.</li>
            <li><b>Circular wait: </b>The circular - wait situation implies the hold-and-wait state or condition, and hence all the four conditions are not completely independent. They are interconnected among each other.</li>
        </ul>
    </p>
    <hr>
    <h2>Methods for Handling Deadlocks</h2>
    <p>
        Normally you can deal with the deadlock issues and situations in one of the three ways mentioned below:
        <ul>
            <li>You can employ a protocol for preventing or avoiding deadlocks, and ensure that the system will never go into a deadlock state.</li>
            <li>You can let the system to enter any deadlock condition, detect it, and then recover.</li>
            <li>You can overlook the issue altogether and assume that deadlocks never occur within the system.</li>
        </ul>
        But is recommended to deal with deadlock, from the 1st option
    </p>
    <hr>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">INTERPROCESS COMMUNICATION(IPC)</span></h1>
    <hr>
    <p>In this chapter, you will learn about the various working capabilities of IPC (Inter-process communication) within an Operating system along with usage. Processes executing concurrently in the operating system might be either independent processes or cooperating processes. A process is independent if it cannot be affected by the other processes executing in the system.    </p>
    <hr>
    <h2>Basics of Interprocess Communication</h2>
    <p>There are numerous reasons for providing an environment or situation which allows process co-operation:
        <ul>
            <li><b>Information Sharing:</b> Since some users may be interested in the same piece of information (for example, a shared file), you must provide a situation for allowing concurrent access to that information.</li>
            <li><b>Computation Speedup:</b> If you want a particular work to run fast, you must break it into sub-tasks where each of them will get executed in parallel with the other tasks. Note that such a speed-up can be attained only when the computer has compound or various processing elements like CPUs or I/O channels.</li>
            <li><b>Modularity:</b>You may want to build the system in a modular way by dividing the system functions into split processes or threads.</li>
            <li><b>Convenience:</b>Even a single user may work on many tasks at a time. For example, a user may be editing, formatting, printing, and compiling in parallel.</li>
        </ul>
        Working together with multiple processes, require an interprocess communication (IPC) method which will allow them to exchange data along with various information. There are two primary models of interprocess communication:
        <ol>
            <li>Shared memory and</li>
            <li>Message passing</li>
        </ol>
        In the shared-memory model, a region of memory which is shared by cooperating processes gets established. Processes can be then able to exchange information by reading and writing all the data to the shared region. In the message-passing form, communication takes place by way of messages exchanged among the cooperating processes.
    </p>
    <p>The two communications models are contrasted in the figure below:
        <img src="C:\Users\harsh\Pictures\Screenshots\Screenshot (420).png">
    </p>
    <hr>
    <h2>Shared Memory Systems</h2>
    <p>Interprocess communication (IPC) usually utilizes shared memory that requires communicating processes for establishing a region of shared memory. Typically, a shared-memory region resides within the address space of any process creating the shared memory segment. Other processes that wish for communicating using this shared-memory segment must connect it to their address space.</p>
    <hr>
    <h2>More on Inter Process Shared Memory</h2>
    <p>Note that, normally what happens, the operating system tries to check one process from accessing other's process's memory. Shared memory needs that two or more processes agree to remove this limitation. They can then exchange information via reading and writing data within the shared areas.</p>
    <p>The form of the data and the location gets established by these processes and are not under the control of the operating system. The processes are also in charge to ensure that they are not writing to the same old location simultaneously.</p>
    <hr>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">WORKING OF MAIN MEMORY</span></h1>
    <hr>
    <p>In this chapter, you will learn about a variety of ways of managing memory along with its working phenomenon. The memory management algorithms differ from a primitive bare - machine technique to different paging and segmentation policies. Each approach has its benefit and demerits. Selection of a varied memory management technique for a specific system depends largely on various factors, particularly on the hardware design of the system. Now you will see many techniques that require hardware support, recent designs that have closely incorporated the hardware and operating system.</p>
    <hr>
    <h2>Basic Hardware</h2>
    <p>Main memory and different registers built inside the processor itself are the only primary storage that the CPU can have the right to use directly by accessing. There are some machine instructions which take memory addresses as arguments or values, but none of them take disk addresses. So, any instructions in implementation and any data which is used by the instructions should have to be in one of these direct accessing storage devices. When the data are not in memory, they have to be moved there before the CPL can work on them.</p>
    <p>Registers which are built into the CPU are accessible within one single cycle of the CPU clock. Most CPUs' can interpret those instructions and carry out simple operations on register contents at the rate of 1 or more process per clock tick. The same may not be said for main memory, which gets accessed via a transaction on the memory bus.    </p>
    <hr>
    <h2>Address Binding</h2>
    <p>Usually, a program inhabits on a disk in a binary executable form of a file. For executing, the program must be fetched into memory and positioned within a process (list in the queue). Depending on the usage of memory management, the process may get moved between disk and memory at the time of its execution. The processes on the disk are then waiting to be brought into main memory for implementing form the input queue. The normal method is to choose any one of the processes in the input queue and to load that process into the memory.</p>
    <p>As the process gets executed, it is able now to access instructions and data from memory. Ultimately, the process expires, and its memory space is declared as available/free. Most systems let user process to exist in any part of the physical memory. Therefore, even if the address space of the computer begins at 00000, the first address of the user process need not have to be 00000. This approach can affect the addresses which the user program can use.</p>
    <p>Normally, the binding of instructions and data onto memory addresses can be done at any of the step given below:
        <ul>
            <li><i><b><u>Compile time:</u></b></i> Compile time is the phase where the process will reside in memory and eventually absolute code can be generated.</li>
            <li><i><b><u>Load time:</u></b></i> At compile time, when the process will reside in memory, the compiler must generate relocatable code. In that case, final binding gets delayed until load time.</li>
            <li><i><b><u>Execution time:</u></b></i> Execution time is the time that a program or instruction takes for executing a particular task.            </li>
        </ul>
    </p>
    <hr>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">VIRTUAL MEMORY</span></h1>
    <hr>
    <p>In this chapter, you will gather knowledge about what virtual memory is and how they are being managed within the operating system, along with its working. Virtual memory is a technical concept that lets the execution of different processes which are not totally in memory. One main benefit of this method is that programs can be larger than the physical memory.</p>
    <p>Also, virtual memory abstracts primary memory into a very large, consistent array of storage that divides logical memory as viewed by the user from that of physical memory. This technique is used to free programmers from the anxiety of memory-storage limitations.</p>
    <hr>
    <h2>Uses of Virtual Memory</h2>
    <p>Virtual memory also permits processes for sharing files easily and for implementing shared memory. Moreover, it offers a well-organized mechanism for process creation. Virtual memory is not that easy to apply and execute. However, this technique may substantially decrease performance if it is not utilized carefully.</p>
    <hr>
    <h2>What is Virtual Address Space(VAS)?</h2>
    <p>The virtual address space of any process is defined as the logical (or virtual) view of how any process gets stored in memory. Normally, this view is where a process begins at a certain logical address — say, addresses location 0—and then exists in contiguous memory. Although, the fact is physical memory might be structured in the form of page frames arid where the physical page frames are assigned to a process that may not be adjacent to each other. It depends on to the memory management unit (MMU) which maps logical pages to physical page frames in memory.</p>
    <hr>
    <h2>The Concept of Demand Paging</h2>
    <p>Think of how an executable program could have loaded from within a disk into its memory. One choice would be to load the complete program in physical memory at a program at the time of execution. However, there is a problem with this approach, which you may not at first need the entire program in memory. So the memory gets occupied unnecessarily.</p>
    <p>An alternative way is to load pages only when they are needed/required initially. This method is termed as demand paging and is commonly utilized in virtual memory systems. Using this demand-paged virtual memory, pages gets only loaded as they are demanded at the time of program execution; pages which are never accessed will never load into physical memory.</p>
    <p>A demand - paging scheme is similar to a paging system with swapping feature where processes exist in secondary memory (typically in a disk). As you want to execute any process, you swap it into memory internally. Rather than swapping the complete process into memory, you can use a "lazy swapper." A "lazy swapper" in no way swaps a page into memory unnecessarily unless that page required for execution.    </p>
    <hr>
    <h2>Hardware Required for the Concept of Demand Paging</h2>
    <p>The hardware required for supporting demand paging is the same that is required for paging and swapping:
        <ul>
            <li><i><u><b>Page table:</b></u></i>Page table can mark an entry invalid or unacceptable using a valid-invalid bit.</li>
            <li><i><u><b>Secondary memory:</b></u></i>Secondary memory retains those pages which are not there in main memory. The secondary memory is generally a high-speed disk. It is also known as a swap device, and the segment of disk used for this purpose is termed as swap space.            </li>
        </ul>
    </p>
    <hr>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">FILE SYSTEM INTERFACE IN OS</span></h1>
    <hr>
    <p>For the majority of users, the file system is the most obvious aspect of any operating system. This provides users the method for storage and access to data as well as programs of the operating system where all the users of the computer system can use it.</p>
    <p>The file system consists of 2 distinct parts:
        <ul>
            <li>a collection of files, that store related data, and</li>
            <li>a directory structure, which organizes and provides information about all the files in the system.</li>
        </ul>
        In this chapter, you will learn about the different file tribute, concepts of file and its storage along with operations on files.
    </p>
    <hr>
    <h2>File Attributes</h2>
    <p>A file is named, for the ease of its users and is referred by its name. A name is usually a string of characters like filename.cpp, along with an extension which designates the file format. Some systems (like Linux) distinguish between uppercase and lowercase characters in names, whereas other systems don't. When a file is given a name, it becomes independent of the process, the user and also the system which created it. Let's suppose, one user might make the file filename.cpp, and another user might be editing that file by deducing its name. The file's owner may write the file to a compact disk (CD) or send it via an e-mail or copy it across a network, and it could still be called filename.cpp on the destination system.</p>
    <hr>
    <h2>Fundamental Components of a File</h2>
    <p>
        A file's attributes vary from one operating system to another but typically consist of these:
        <ul>
            <li><b><u>Name:</u></b>Name is the symbolic file name and is the only information kept in human readable form.</li>
            <li><b><u>Identifier:</u></b>This unique tag is a number that identifies the file within the file system; it is in non-human-readable form of the file.</li>
            <li><b><u>Type:</u></b>This information is needed for systems which support different types of files or its format.</li>
            <li><b><u>Location:</u></b>This information is a pointer to a device which points to the location of the file on the device where it is stored.</li>
            <li><b><u>Size:</u></b>The current size of the file (which is in bytes, words, etc.) which possibly the maximum allowed size gets included in this attribute.</li>
            <li><b><u>Protection:</u></b> Access-control information establishes who can do the reading, writing, executing, etc.</li>
            <li><b><u>Date, Time & user identification:</u></b>This information might be kept for the creation of the file, its last modification and last used. These data might be useful for in the field of protection, security, and monitoring its usage.            </li>
        </ul>
    </p>
    <hr>
    <h2>File Operations</h2>
    <p>
        A file is an abstract data type. For defining a file properly, we need to consider the operations that can be performed on files. The operating system can provide system calls to create, write, read, reposition, delete, and truncate files. There are six basic file operations within an Operating system. These are:
        <ul>
            <li><b><u>Creating a File: </u></b>There are two steps necessary for creating a file. First, space in the file system must be found for the file. We discuss how to allocate space for the file. Second, an entry for the new file must be made in the directory.</li>
            <li><b><u>Writing a File: </u></b>To write to a file, you make a system call specify about both the name of the file along with the information to be written to the file.</li>
            <li><b><u>Reading a File: </u></b> To read from a file, you use a system call which specifies the name of the file and where within memory the next block of the file should be placed.</li>
            <li><b><u>Repositioning a File: </u></b> The directory is then searched for the suitable entry, and the 'current-file-position' pointer is relocating to a given value. Relocating within a file need not require any actual I/O. This file operation is also termed as 'file seek.'</li>
            <li><b><u>Deleting a File: </u></b> For deleting a file, you have to search the directory for the specific file. Deleting that file or directory release all file space so that other files can re-use that space.</li>
            <li><b><u>Truncating a File: </u></b>The user may wish for erasing the contents of a file but keep the attributes same. Rather than deleting the file and then recreate it, this utility allows all attributes to remain unchanged — except the file length — and let the user add or edit the file content.            </li>
        </ul>
    </p>
    <hr>
    <h1 ><span class="color_h1">FILE SYSTEM IMPLEMENTATION OS</span></h1>
    <p>As you saw in the last tutorial, the file system provides the means for online storage and accessing of file contents, including data and its programs. The file system exists in permanently on secondary storage that is designed for holding a large amount of permanent data. This tutorial is mainly concerned with issues related to file storage and accessing them on the most common secondary storage standard, i.e., the disk.</p>
    <hr>
    <h2>File-System Structure</h2>
    <p>
        Disks offer the massive amount of secondary storage where a file system can be maintained. They have two characteristics which make them a suitable medium for storing various files -
        <ul>
            <li>A disk can be used to rewrite in place; it is possible to read a chunk from the disk, modify the chunk and write it back there in the same place.</li>
            <li>A disk can access directly any given block of data it contains. Hence, it is easy to access any file either in sequence or at random and switching from one single file to another need only to move the read-write heads and wait for the disk to rotate to that specific location.            </li>
        </ul>
    </p>
    <hr>
    <h2>Basic File System Structure</h2>
    <p>The basic file system requires only issuing generic commands for the appropriate device driver mainly for reading and writing physical blocks on the disk. Each physical block can be recognized by its numeric disk address (like this: drive 1, cylinder 62, track 2, sector 14).</p>
    <hr>
    <h2>File-System Implementation</h2>
    <p>
        Numerous on-disk and in-memory configurations and structures are being used for implementing a file system. These structures differ based on the operating system and the file system but applying some general principles. Here they are portrayed below:
        <ul>
            <li>A boot control block usually contains the information required by the system for booting an operating system from that volume. When the disks do not contain any operating system, this block can be treated as empty. This is typically the first chunk of a volume. In UFS, this is termed as the boot block; in NTFS, it is the partition boot sector.</li>
            <li>A volume control block holds volume or the partition details, such as the number of blocks in the partition, size of the blocks or chunks, free-block count along with free-block pointers. In UFS, it is termed as superblock; in NTFS, it is stored in the master file table.</li>
            <li>A directory structure per file system is required for organizing the files. In UFS, it held the file names and associated 'inode' numbers. In NTFS, it gets stored in the master file table.</li>
            <li>The FCB contains many details regarding any file which includes file permissions, ownership; the size of file and location of data blocks. In UFS, it is called the inode. In NTFS, this information gets stored within the master file table that uses a relational database (RDBM) structure, using a row per file.</li>
        </ul>
    </p>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">OS INPUT OUTPUT I/O</span></h1>
    <hr>
    <p>The three major jobs of a computer are Input, Output, and Processing. In a lot of cases, the most important job is Input / Output, and the processing is simply incidental. For example, when you browse a web page or edit any file, our immediate attention is to read or enter some information, not for computing an answer. The primary role of the operating system in computer Input / Output is to manage and organize I/O operations and all I/O devices. In this chapter, you will learn about the various uses of input output devices concerning the operating system.    </p>
    <hr>
    <h2>Overview of I/O System</h2>
    <p>The controlling of various devices that are connected to the computer is a key concern of operating-system designers. This is because I/O devices vary so widely in their functionality and speed (for example a mouse, a hard disk and a CD-ROM), varied methods are required for controlling them. These methods form the I/O sub-system of the kernel of OS that separates the rest of the kernel from the complications of managing I/O devices.    </p>
    <hr>
    <h2>I/O Hardware</h2>
    <p>Computers operate many huge kinds of devices. The general categories of storage devices are like disks, tapes, transmission devices (like network interface cards, modems) and human interface devices (like screen, keyboard, etc.).</p>
    <p>A device communicates with the operating system of a computer by transferring signals over cable or even through the air. The peripheral devices communicate with the machine through a connection point also called ports— (one example is a serial port). When devices use a set of wires or cables, that connecting cables are called a "bus." A bus is a collection of wires and a firmly defined protocol which specifies a set of messages that can be sent on the wires.</p>
    <hr>
    <h2>OS Using I/O Port</h2>
    <p>
        An I/O port usually consists of four different registers. These are (1) status, (2) control, (3) data-in, and (4) data-out registers.
        <ul>
            <li>The data-in register is read by the host for getting input.</li>
            <li>The data-out register is written by the host for sending output.</li>
            <li>The status register holds bits which can be read by the host.</li>
            <li>The control register is written by the host for starting a command or for changing the mode of any device.</li>
            <li>The data registers are usually 1 to 4 bytes in size. Some of the controllers have FIFO chips which hold several bytes of input or output data for expanding the capacity of the controller beyond the size of the data register.</li>
        </ul>
    </p>
    <hr>
    <h2>Polling</h2>
    <p>The complete protocol used to interact with the host and a controller can be difficult for the OS, but the necessary handshaking notion is simple. You can express handshaking with an example. You assume that 2 bits have been used for coordinating the producer - consumer relationship among the controller and the host. The controller points to its state using the busy bit in the status register.</p>
    <p>
        The host marks output through a port, with the controller using handshaking like:
        <ol>
            <li>The host frequently reads the busy bit till that bit gets clear.</li>
            <li>The host then sets the write, bit in the command register and then writes a byte to the data-out register.</li>
            <li>The host then puts the command-ready bit.</li>
            <li>As the controller notices that the command - ready bit has been set, it sets the busy bit.</li>
            <li>The controller then reads the command register. It reads the data-out register for getting the byte and performs the I/O to the device.</li>
            <li>The controller clears the command - ready bit then clears the error bit within the status register for indicating that the device I/O succeeded.</li>
        </ol>
    </p>
    <hr>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">MULTIMEDIA IN OS</span></h1>
    <hr>
    <p>In earlier chapters, you might have learned about how operating systems handle general data, like text files, programs, binary files, word-processing documents and also spreadsheets. Moreover, operating systems may get the task to handle different kinds of data as well which comes in the category of multimedia. A recent trend in technology is the inclusion of multimedia data within computer systems. Multimedia kind of data consists of continuous media in the form of files (audio or video) data as well as conventional files to run. Continuous media data vary from conventional data like that where continuous media files — such as frames of video or images or audio files — must be delivered according to certain time restrictions.    </p>
    <hr>
    <h2>What is Multimedia?</h2>
    <p>The word multimedia depicts a large range of applications which are in popular use now-a-days. This term covers a large category that includes audio and video files like MP3 audio files, movies, short video clips and flash / animation files of movie previews or news stories that are being downloaded via the Internet.</p>
    <p>Multimedia concept also includes live webcasting (i.e. broadcasting over the World Wide Web) of various events or sports. Multimedia applications should not have to be either audio or video; instead, a multimedia application can include a mixture of both.    </p>
    <hr>
    <h2>What is Media Delivery?</h2>
    <p>Multimedia data gets stored in the file system just as any other data. The main dissimilarity between a regular file and multimedia file is that the multimedia files have to be accessed at an exact rate but accessing a regular file requires no particular timing. The video is usually represented by a sequence of images which is known as frames which are used to display in rapid succession. The faster the frames are displayed to users the smoother the video looks. Mostly, a rate of 24 to 30 frames per second has to be necessary for the video for appearing smooth to human eyes.</p>
    <p>
        When any data gets delivered from the local file system, you can refer to that delivery as 'local playback'. Multimedia files can also be stored on a remote server and delivered to a client across a network with a technique called streaming.<br>There are two types of streaming techniques:
        <ul>
            <li>progressive download and</li>
            <li>real-time streaming</li>
        </ul>
        With a progressive download, any media file having both audio and video can be downloaded and stored on the users' local file system. Real-time streaming varies from progressive download wherein the media file gets streamed to the client but can be only played—and not stored/downloaded — by the client.<br>
        As the media file does not get stored on the client system, real-time streaming is much preferred to progressive download for media files which might be too large to store on system, like long videos and Internet radio or TV broadcasts.
    </p>
    <hr>
    <h2>Characterstics of Multimedia Systems</h2>
    <p>The demands of multimedia systems are nothing like the demands of conventional applications. Mostly, multimedia systems may have the below-mentioned characteristics:
        <ul>
            <li>Multimedia files can be relatively large. Let's take an example; a 100-minute MPEG-1 video file uses roughly 1.125 GB of storage, 100 minutes of high-definition television needs roughly 15 GB of storage.</li>
            <li>Continuous media might need very high data rates. Think of a digital video, wherein a frame of color video is displayed at a resolution having 800 x 600.</li>
            <li>Multimedia applications are quite sensitive to time delays at some point in playback.</li>
        </ul>
    </p>
    <hr>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">VIRTUALIZATION IN OS</span></h1>
    <hr>
    <p>After the concept of server virtualization and application's virtualization, the field of virtualization evolved to a next level. Jointly with VDI (Virtual Desktop Infrastructure), Virtualization of Operating System (OS) is one of those procedures that get popular in the current market. The company Ardence (which is now a part of Citrix) has initiated the concept of OS Virtualization technique. In this chapter, you will learn about the basics of Virtualization in Operating System.</p>
    <hr>
    <h2>What is OS Virtualization?</h2>
    <p>With an operating system, virtualization does not remain pre-installed or preloaded on the local device, and no hard disk drive is required. The whole lot of things is run from the network using a type of virtual disk. Through the current implementations, this virtual disk gets the disk image file that is stored on a remote server.    </p>
    <hr>
    <h2>Types of Virtual Desks</h2>
    <p>
        There are two categories of Virtual Disks in the majority implementations:
        <ul>
            <li><u><b>Private Virtual Disk:</b></u> A private virtual disk generally used by a single client only, just similar to a local hard disk. Based on the rights assigned, the user can save the information on that virtual disk. So as the client has restarted the settings get retained, just like working with a physical local hard disk.</li>
            <li><u><b>Shared/Common Virtual Disk:</b></u>Several clients require a shared Virtual Disk at a time. During this usage, changes get saved in a special type of cache memory, but as the client shuts down or restarts, the cache gets cleared.<br> A Virtual Disk gets created by implementing a kind of imaging technique. Now you know, mostly, what operating system virtualization is, let's now see into a bit more detail on how it works and what components are concerned.</li>
        </ul>
    </p>
    <hr>
    <h2>How Does OS Virtualization works?</h2>
    <p>The first section is the OS Virtualization server. It is the central point in the OS Virtualization structure. The server places the streaming of the data on the virtual disks for the client and also establishes which client will get connected to which virtual disk (by the use of database where this information resides).

        <br>Secondly, there has to be client that contacts the server for getting connected to the virtual disk and requests for components stored on virtual disk for running the operating system.</p>
    <hr>
    <h2>Connecting to OS Virtualization as Server</h2>    
    <p>First, you start the machine and set up a link with the OS Virtualization server. Most products offer various probable methods for connecting to the server. One of the frequently used methods is using a PXE service, but also a bootstrap is used a lot. Moreover, each method initialized the NIC (Network Interface Card), receiving a (DHCP-oriented) IP address and an association to the server.</p>
    <hr>
    <h2>What Happens at Virtual Disk Connection?</h2>
    <p>As the connection is established among the client and the server, the server looks through its database for checking whether the client is known and what virtual disk(s) needs to be assigned to the client. As more than one virtual disk gets connected then a boot menu is displayed on the client. When only one disk is assigned, that disk will be connected to the client later.</p>
    <hr>
    <h1 ><span class="color_h1" style="color:rgb(76, 27, 97)">DISTRIBUTED IN OS</span></h1>
    <hr>
    <p>In this chapter, you begin to learn with an examination of some of the primary concepts in distributed software which includes client - server architecture, message passing technique, and remote procedure calls. Then you will examine the increasingly significant cluster architecture.</p>
    <hr>
    <h2>What is Client-Server Computing</h2>
    <p>As with other developing phases of the computer field, the client/server computing comes with its new collection of terminologies. As the term depicts, a client/server environment is occupied by clients and servers. The client systems are generally single - user workstations or computers which provide a highly user-friendly interface for the end-user.

        <br><br>The client based station usually presents the type of graphical interface (GUI) which is most comfortable to users that include the requirement of windows and a mouse. Microsoft Windows and Mac OS offers an example of those types of interfaces. Client-based applications are customized for simplicity in using and include familiar tools like a spreadsheet. Every server in the client/server environment allows a set of shared services for the clients. The most common category of the server at present used is the database servers.
        
    </p>
    <hr>
    <h2>Distributed Client/Server Architecture's Terminologies</h2>
    <ol>
        <li><b>Applications Programming Interface (API): </b>It is a set of task, and it calls programs which allow clients as well as servers for intercommunicating with each other.</li>
        <li><b>Client / User: </b>It is a networked information requester which is typically a computer system or workstation which can query database and / or other information from a server.</li>
        <li><b>Middleware: </b>It is a set of drivers, API's and / or other software which improves the connection among a client application with a server.</li>
        <li><b>Relational Database: </b>It is a type of database wherein the information access becomes limited to the selection of rows which satisfy all search criteria.</li>
        <li><b>Server: </b>It is also a computer, typically a high-powered systems and workstations or a minicomputer or a mainframe, which houses information to manipulate the networked clients.</li>
        <li><b>Structured Query Language (SQL): </b>It is a language developed by IBM (International Business Machines) and ANSI had standardized it for addressing, producing, updating and querying RDB's (relational databases).</li>
    </ol>
    <hr>
    <h2>Distributed Message Passing</h2>
    <p>It is generally the case in any distributed processing structures/systems where the computers don't share main memory instead each of them is an isolated computer system. Thus, inter-processor communication mechanisms which rely on shared memory, such as semaphores, can't be used. Hence, techniques which depend on message passing are used.

        <br><br>The 1st one is the straightforward application for messages as they are utilized in a single system. The 2nd follows a separate technique which relies on message passing as a essential function which is the remote procedure call.
    </p>
    <hr>
    <h2>Clusters in Distributed Systems</h2>
    <p>Clustering is a substitute to symmetric multiprocessing as it is another way of providing high performance and availability which is particularly attractive for server applications. You can define a cluster as a collection of interconnected, complete computers working together as a combined computing resource which can create the structure of being one machine. The term complete computer tells that a system can run on its own, separately from the cluster and, each computer in the cluster is usually referred to as a node.</p>
    <hr>
 </body>
</html>